特殊的线性[[数据结构]]，它按照后进先出（LIFO）的原则组织数据。广泛应用于程序中的各种场景，如函数调用、递归表达式求值等。
#### 栈的操作
1. 入栈（Push）：将一个元素添加到栈的顶部。
2. 出栈（Pop）：移除栈顶的元素
3. 检查栈是否为空：判断栈中是否有元素。
4. 返回栈顶元素：获取栈顶的元素但不移除他
#### 栈的实现
栈可以通过数组或[[链表]]来实现。
数组实现的栈
```C
#include <stdio.h>
#include <stdlib.h>

//定义栈结构
typedef struct Stack{
	int *arr;
	int top;
	int capacity;
}Stack;

//初始化栈
void initStack(Stack *s,int capacity)
{
	s->arr = (int *)malloc(sizeof(int) * capacit);
	s->top = -1;
	s->capacity = capacity;
}

//入栈
void push(Stack *s,int val)
{
	if(s->top >= s->capacity - 1)
	{
		printf("Stack overflow\n");
		return;
	}
	s->arr[++s->top] = val;
}

//出栈
int pop(Stack *s)
{
	if(s->top < 0)
	{
		printf("Stack underflow\n");
		return -1;
	}
	return s->arr[s->top--];
}

//检查栈是否为空
int isEmpty(Stack *s)
{
	return s->top < 0;
}

//返回栈顶元素
int peek(Stack *s)
{
	if(s->top < 0)
	{
		printf("Stack is empty\n");
		return -1;
	}
	return s->arr[s->top];
}

int main()
{
	Stack s;
	initStack(&s,10);
	
	push(&s,1);
	push(&s,2);
	push(&s,3);
	
	printf("Peek:%d\n",peek(&s));
	printf("Peek:%d\n",pop(&s));
	printf("Peek:%d\n",pop(&s));
	printf("IsEmpty:%d\n",isEmpty(&s));
	
	return 0;
}
```
**链表**实现的栈
```C
#include <stdio.h>
#include <stdlib.h>

//定义链表节点
typedef struct Node
{
	int data;
	steuct Node *next;
}Node;

//定义栈结构
tpedef struct Stack
{
	Node *top;

}Stack;

//初始化栈
void initStack(Stack *s)
{
	s->top = NULL;
}

//入栈
void push(Stack *s,int val)
{
	Node *newNode = (Node *)malloc(sizeof(Node));
	newNode->data = val;
	newNode->next = s->top;
	s->top = newNode;
}

//出栈
int pop(Stack *s)
{
	if(s->top == NULL)
	{
		printf("Stack underflow\n");
		return -1;
	}
	Node  *temp = s->top;
	int data = temp->data;
	s->top = temp->next;
	free(temp);
	return data;
}

//检查是否为空
int isEmpty(Stack *s)
{
	return s->top == NULL;
}

//返回栈顶元素
int peek(Stack *s)
{
	if(s->top == 0)
	{
		printf("Stack is empty\n");
		return -1;
	}
	return s->top->data;
}

int main()
{
	Stack s;
	initStack(&s);
	
	push(&s,1);
	push(&s,2);
	push(&s,3);
	
	printf("Peek:%d\n",peek(&s));
	printf("Peek:%d\n",pop(&s));
	printf("Peek:%d\n",pop(&s));
	printf("IsEmpty:%d\n",isEmpty(&s));
	
	return 0;
}
```
#### 性能分析
- 数组实现的栈：
	- [[时间复杂度]]：入栈和出栈的时间复杂度为O(1),因为数组中的元素是连续存储的，可以直接通过索引访问。
	- [[空间复杂度]]：空间复杂度为O(n)，其中n是栈的容量。
- 链表实现的栈：
	-   时间复杂度：入栈和出栈操作的时间复杂度为O(1)，因为链表节点可以直接通过指针访问。
	- - 空间复杂度：空间复杂度为O(n)，其中n是栈中元素的数量。

当需要频繁的进行入栈和出栈操作时，数组实现的栈可能是好的选择；当栈的大小不固定时链表的栈可能更合适。
#### 栈的应用场景
1. **函数调用**：当一个函数调用另一个函数时，系统会创建一个栈来存储当前函数的状态，包括返回地址、局部变量和参数。当被调用的函数完成后，系统会从栈中恢复调用函数的状态并继续执行。
2. **递归**：递归函数调用栈用于存储每次递归调用的状态，包括局部变量和返回地址。递归结束后，系统会从栈中逐个恢复这些状态，直到回到最初的调用点。
3. **表达式求值**：在计算表达式时，可以使用栈来存储操作数和操作符，以便按照运算符优先级进行计算。
4.  **后缀表达式求值**：后缀表达式（也称为逆波兰表达式）是一种不需要括号的表达式表示法，其中运算符位于操作数之后。可以使用栈来计算这种表达式的值。
5. **括号匹配**：在编写代码时，括号匹配是非常重要的。可以使用栈来检查一个字符串中的括号是否匹配。
```C
#include <stdio.h>
#include <stdlib.h>
 
// 定义栈结构
typedef struct Stack {
    int *arr;
    int top;
    int capacity;
} Stack;
 
// 初始化栈
void initStack(Stack *s, int capacity) {
    s->arr = (int *)malloc(sizeof(int) * capacity);
    s->top = -1;
    s->capacity = capacity;
}
 
// 入栈
void push(Stack *s, int val) {
    if (s->top >= s->capacity - 1) {
        printf("Stack overflow\n");
        return;
    }
    s->arr[++s->top] = val;
}
 
// 出栈
int pop(Stack *s) {
    if (s->top < 0) {
        printf("Stack underflow\n");
        return -1;
    }
    return s->arr[s->top--];
}
 
// 检查栈是否为空
int isEmpty(Stack *s) {
    return s->top < 0;
}
 
// 返回栈顶元素
int peek(Stack *s) {
    if (s->top < 0) {
        printf("Stack is empty\n");
        return -1;
    }
    return s->arr[s->top];
}
 
// 计算后缀表达式的值
int evaluatePostfix(char *exp) {
    Stack s;
    initStack(&s, 100);
    
    char *token = strtok(exp, " ");
    while (token != NULL) {
        if (isdigit(token[0])) {
            push(&s, atoi(token));
        } else {
            int b = pop(&s);
            int a = pop(&s);
            if (strcmp(token, "+") == 0) {
                push(&s, a + b);
            } else if (strcmp(token, "-") == 0) {
                push(&s, a - b);
            } else if (strcmp(token, "*") == 0) {
                push(&s);
            } else if (strcmp(token, "/") == 0) {
                push(&s);
            }
        }
        token = strtok(NULL, " ");
    }
    return pop(&s);
}
 
int main() {
    char *exp = "3 4 + 2 *";
    printf("The value of the expression is: %d\n", evaluatePostfix(exp));
    return 0;
}

```
#### 栈的注意事项
1. 栈溢出与栈下溢：栈溢出是指尝试在栈已满时进行入栈操作，而栈下溢是指尝试在栈为空时进行出栈操作。这两种情况都会导致程序运行异常，因此，在入栈和出栈操作之前，应分别检查栈是否已满和是否为空。
2. [[指针]]操作：在链表实现的栈中，指针操作尤为重要。需要确保指针的正确性，避免空指针访问或循环引用。例如，在出栈操作后，应将指针指向下一个元素，而不是保留指向被移除元素的指针。
3. 内存管理：在实现栈时，需要正确管理内存。例如，在创建栈时应分配足够的空间，在不再需要栈时应释放其占用的内存。
#### 编译器中的栈
在编译器中，栈用于存储中间代码和寄存器分配等信息。
#### 解释器中的栈
在解释器中，栈用于存储和处理程序中的指令和数据。