特殊的线性[[数据结构]]，它按照后进先出（LIFO）的原则组织数据。广泛应用于程序中的各种场景，如函数调用、递归表达式求值等。
#### 栈的操作
1. 入栈（Push）：将一个元素添加到栈的顶部。
2. 出栈（Pop）：移除栈顶的元素
3. 检查栈是否为空：判断栈中是否有元素。
4. 返回栈顶元素：获取栈顶的元素但不移除他
#### 栈的实现
栈可以通过数组或[[链表]]来实现。
数组实现的栈
```C
#include <stdio.h>
#include <stdlib.h>

//定义栈结构
typedef struct Stack{
	int *arr;
	int top;
	int capacity;
}Stack;

//初始化栈
void initStack(Stack *s,int capacity)
{
	s->arr = (int *)malloc(sizeof(int) * capacit);
	s->top = -1;
	s->capacity = capacity;
}

//入栈
void push(Stack *s,int val)
{
	if(s->top >= s->capacity - 1)
	{
		printf("Stack overflow\n");
		return;
	}
	s->arr[++s->top] = val;
}

//出栈
int pop(Stack *s)
{
	if(s->top < 0)
	{
		printf("Stack underflow\n");
		return -1;
	}
	return s->arr[s->top--];
}

//检查栈是否为空
int isEmpty(Stack *s)
{
	return s->top < 0;
}

//返回栈顶元素
int peek(Stack *s)
{
	if(s->top < 0)
	{
		printf("Stack is empty\n");
		return -1;
	}
	return s->arr[s->top];
}

int main()
{
	Stack s;
	initStack(&s,10);
	
	push(&s,1);
	push(&s,2);
	push(&s,3);
	
	printf("Peek:%d\n",peek(&s));
	printf("Peek:%d\n",pop(&s));
	printf("Peek:%d\n",pop(&s));
	printf("IsEmpty:%d\n",isEmpty(&s));
	
	return 0;
}
```
**链表**实现的栈
```C
#include <stdio.h>
#include <stdlib.h>

//定义链表节点
typedef struct Node
{
	int data;
	steuct Node *next;
}Node;

//定义栈结构
tpedef struct Stack
{
	Node *top;

}Stack;

//初始化栈
void initStack(Stack *s)
{
	s->top = NULL;
}

//入栈
void push(Stack *s,int val)
{
	Node *newNode = (Node *)malloc(sizeof(Node));
	newNode->data = val;
	newNode->next = s->top;
	s->top = newNode;
}

//出栈
int pop(Stack *s)
{
	if(s->top == NULL)
	{
		printf("Stack underflow\n");
		return -1;
	}
	Node  *temp = s->top;
	int data = temp->data;
	s->top = temp->next;
	free(temp);
	return data;
}

//检查是否为空
int isEmpty(Stack *s)
{
	return s->top == NULL;
}

//返回栈顶元素
int peek(Stack *s)
{
	if(s->top == 0)
	{
		printf("Stack is empty\n");
		return -1;
	}
	return s->top->data;
}

int main()
{
	Stack s;
	initStack(&s);
	
	push(&s,1);
	push(&s,2);
	push(&s,3);
	
	printf("Peek:%d\n",peek(&s));
	printf("Peek:%d\n",pop(&s));
	printf("Peek:%d\n",pop(&s));
	printf("IsEmpty:%d\n",isEmpty(&s));
	
	return 0;
}
```
#### 性能分析
- 数组实现的栈：
	- [[时间复杂度]]：入栈和出栈的时间复杂度为O(1),因为数组中的元素是连续存储的，可以直接通过索引访问。
	- [[空间复杂度]]：空间复杂度为O(n)，其中n是栈的容量。
- 链表实现的栈：
	-   时间复杂度：入栈和出栈操作的时间复杂度为O(1)，因为链表节点可以直接通过指针访问。
	- - 空间复杂度：空间复杂度为O(n)，其中n是栈中元素的数量。

