链表是一种常见的[[数据结构]]，用于存储线性数据集合。在C语言中，链表由一系列节点组成，每个节点包含数据和指向下一个节点的指针。
#### 链表基础
```C
typedef struct Node
{
	int data;
	struct Node *next;
}Node，*LinkedList;
//Node表示结点类型，LinkedList表示指向Node结点类型的指针类型
```
定义了一个名为Node的结构体。
data为自定义的数据类型，next为指向下一个链表节点的指针。
相比起数组，链表解决了数组不方便移动，插入，删除元素的弊端，但链表付出了更加大的内存牺牲换来了这些功能。
#### 单向链表的初始化
```C
LinkedList listinit()
{
	Node *L;
	L = (Node *)malloc(sizeof(Node));
	if(L == NULL)
	{
		printf("申请空间失败");
		exit(0);
	}
	L->next = NULL;
}
```
一定要判断是否开辟空间失败，否则有未知的风险。
头插入法创建单链表：利用指针指向下一个节点元素的方式进行逐个创建，使用头插入法最终得到的结果是逆序的。
```C
//头插法建立单链表
LinkedList LinkedListCreatH()
{
	Node *L;
	L = (Node *)malloc(sizeof(Node));
	L->next = NULL;
	
	int x;
	while(scanf("%d",&x) != EOF)
	{
		Node *p;
		p = (Node *)malloc(sizeof(Node)); //申请新的结点
		p->data = x;                      //结点数据域赋值
		p->next = L->next;  //将结点插入到表头L->|2|->|1|->NULL
		L->next = p;
	}
	return L;
}
```
尾插入法创建单链表：结点的次序和输入的顺序一致，必须增加一个尾指针r，使其始终指向当前链表的尾结点。
```C
LinkedList LinkedListCreat()
{
	Node *L;
	L = (Node *)malloc(sizeof(Node));
	L->next = NULL;
	Node *r;
	r = L;
	int x;
	while(scanf("%d",&x) != EOF)
	{
		Node *p;
		p = (Node *)malloc(sizeof(Node));
		p->data = x;
		r->next = p;
		r = p;
	}
	r->next = NULL;
	return L;
}
```
#### 遍历单链表
从头开始，逐步向后进行每一个元素的访问。
```C
void printList(LinkedList L)
{
	Node *p = L->next;
	int i = 0;
	while(p)
	{
		printf("第%d个元素的值为:%d\n",++i,)
	}
}
```
对元素进行修改操作
```C
LinkedList LinkedListReplace(LinkedList L,int x,int k)
{
	Node *p = L->next;
	int i = 0;
	while(p)
	{
		if(p->data == x)
		{
			p->data = k;
		}
		p = p->next;
	}
	return L;
}
```
