### 函数参数的传递方法（值传递和地址传递）
值传递是将实参的值复制到函数的形参中，在这种情况下，对形参的修改不会影响到实参的值。
```C
#include <stdio.h>

void modify(int a)
{
	a = 42;
}

int main()
{
	int x= 7;
	modify(x);
	printf("x = %d\n",x);
	return 0;
}
```
在函数内部将x的值修改为42，但x的原始值不变。
地址传递，是将参数的地址（指针）复制到函数的形参中。这种情况对形参的修改将会影响到实参。
```C
#include <stdio.h>

void modify_by_address(int *a)
{
*a = 42;
}

int main()
{
in x = 7;
modify_by_address(&x);
printf("x = %d\n",x);
return 0;
}
```
modify_by_address函数接收x的地址，并在函数内部通过指针修改x的值为42，x的原始值被修改。
### 默认参数
C不支持函数的默认参数，但是可以通过一些技巧实现类似默认参数的效果。
```C
#include <stdio.h>
 
void print_max(int a, int b, int c) {
    if (a > b && a > c) 
        printf("%d is maximum\n", a);
     else if (b > c) 
        printf("%d is maximum\n", b);
     else 
        printf("%d is maximum\n", c);
    
}
 
void print_max(int a, int b) {
    print_max(a, b, INT_MIN); // 使用最小整数值作为默认参数
}
 
int main() {
    int x = 10, y = 20;
    print_max(x, y); // 输出 20 is maximum
    return 0;
}
```
### 可变参数列表
允许函数接受可变数量的参数。这通过va_list,va_start,va_arg,va_end等宏来实现。
```C
#include <stdio.h>
#include <stdarg.h>

double average(int count,...)
{
	va_list args;
	double sum = 0.0;
	va_start(args,count);
for(int i = 0;i < count;i++)
	sum += va_arg(args,int);
va_end(args);
return sum / count;
}

int main()
{
	double avg = average(4,1,2,3,4);
	printf("Average:%f\n",avg);
	return 0;
}
```
average函数接收了一个int类型的参数count，表示后续可变参数的数量，然后通过va_list来访问这些参数。va_start宏初始化va_list，va_arg宏用于访问下一个参数，va_end用于清理va_list。